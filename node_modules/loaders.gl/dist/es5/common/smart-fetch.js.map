{"version":3,"sources":["../../../src/common/smart-fetch.js"],"names":["smartFetch","url","loaders","options","fetch","then","response","text","smartParse","loader","getLoader","parseText","Error","name","extension","path","extname","length","substr","toLowerCase","testText"],"mappings":";;;;;;;;AAAA;;;;AAEO,SAASA,UAAT,CAAoBC,GAApB,EAAyBC,OAAzB,EAAkCC,OAAlC,EAA2C;AAChD;AACA,SAAOC,KAAK,CAACH,GAAD,CAAL,CACJI,IADI,CACC,UAAAC,QAAQ;AAAA,WAAIA,QAAQ,CAACC,IAAT,EAAJ;AAAA,GADT,EAEJF,IAFI,CAEC,UAAAE,IAAI;AAAA,WAAIC,UAAU,CAACD,IAAD,EAAON,GAAP,CAAd;AAAA,GAFL,CAAP;AAGD,C,CAED;;;AACO,SAASO,UAAT,CAAoBD,IAApB,EAA0BN,GAA1B,EAA+BC,OAA/B,EAAwCC,OAAxC,EAAiD;AACtD,MAAMM,MAAM,GAAGC,SAAS,CAACT,GAAD,EAAMM,IAAN,EAAYL,OAAZ,CAAxB;;AACA,MAAI,CAACO,MAAM,CAACE,SAAZ,EAAuB;AACrB,UAAM,IAAIC,KAAJ,WAAaH,MAAM,CAACI,IAApB,gCAAN;AACD;;AAED,SAAOJ,MAAM,CAACE,SAAP,CAAiBJ,IAAjB,EAAuBJ,OAAvB,CAAP;AACD,C,CAED;;;AACA,SAASO,SAAT,CAAmBT,GAAnB,EAAwBM,IAAxB,EAA8BL,OAA9B,EAAuC;AACrC;AACA,MAAIY,SAAS,GAAGC,cAAKC,OAAL,CAAaf,GAAb,KAAqBA,GAArC;;AACA,MAAIa,SAAS,CAACG,MAAV,IAAoBH,SAAS,CAAC,CAAD,CAAT,KAAiB,GAAzC,EAA8C;AAC5CA,IAAAA,SAAS,GAAGA,SAAS,CAACI,MAAV,CAAiB,CAAjB,EAAoBC,WAApB,EAAZ;AACD;;AALoC;AAAA;AAAA;;AAAA;AAOrC,yBAAqBjB,OAArB,8HAA8B;AAAA,UAAnBO,MAAmB;;AAC5B,UAAIA,MAAM,CAACK,SAAP,KAAqBA,SAAzB,EAAoC;AAClC,eAAOL,MAAP;AACD;AACF;AAXoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAarC,0BAAqBP,OAArB,mIAA8B;AAAA,UAAnBO,OAAmB;;AAC5B,UAAIA,OAAM,CAACI,IAAP,CAAYM,WAAZ,KAA4BL,SAAhC,EAA2C;AACzC,eAAOL,OAAP;AACD;AACF;AAjBoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAmBrC,0BAAqBP,OAArB,mIAA8B;AAAA,UAAnBO,QAAmB;;AAC5B,UAAIA,QAAM,CAACW,QAAP,IAAmBX,QAAM,CAACW,QAAP,CAAgBb,IAAhB,CAAvB,EAA8C;AAC5C,eAAOE,QAAP;AACD;AACF;AAvBoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyBrC,SAAO,IAAP;AACD","sourcesContent":["import path from 'path';\n\nexport function smartFetch(url, loaders, options) {\n  /* global fetch */\n  return fetch(url)\n    .then(response => response.text())\n    .then(text => smartParse(text, url));\n}\n\n// Find a loader that works for extension/text\nexport function smartParse(text, url, loaders, options) {\n  const loader = getLoader(url, text, loaders);\n  if (!loader.parseText) {\n    throw new Error(`${loader.name} loader cannot handle text`);\n  }\n\n  return loader.parseText(text, options);\n}\n\n// Search the loaders array argument for a loader that matches extension or text\nfunction getLoader(url, text, loaders) {\n  // Get extension without\n  let extension = path.extname(url) || url;\n  if (extension.length && extension[0] === '.') {\n    extension = extension.substr(1).toLowerCase();\n  }\n\n  for (const loader of loaders) {\n    if (loader.extension === extension) {\n      return loader;\n    }\n  }\n\n  for (const loader of loaders) {\n    if (loader.name.toLowerCase === extension) {\n      return loader;\n    }\n  }\n\n  for (const loader of loaders) {\n    if (loader.testText && loader.testText(text)) {\n      return loader;\n    }\n  }\n\n  return null;\n}\n"],"file":"smart-fetch.js"}