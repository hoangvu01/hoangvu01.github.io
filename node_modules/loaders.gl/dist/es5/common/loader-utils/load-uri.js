"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadUri = loadUri;
exports.parseDataUri = parseDataUri;

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng
var fs = module.require && module.require('fs');
/* global Buffer */


function loadUri(uri) {
  var rootFolder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';

  if (uri.startsWith('http:') || uri.startsWith('https:')) {
    return Promise.reject(new Error('request based loading of URIs not implemented'));
  }

  if (uri.startsWith('data:')) {
    return Promise.resolve(parseDataUri(uri));
  }

  if (!fs) {
    return Promise.reject(new Error('Cannot load file URIs in browser'));
  }

  var filePath = _path.default.join(rootFolder = '.', uri);

  return fs.readFileAsync(filePath).then(function (buffer) {
    return {
      buffer: buffer
    };
  });
}
/**
 * Parses a data URI into a buffer, as well as retrieving its declared MIME type.
 *
 * @param {string} uri - a data URI (assumed to be valid)
 * @returns {Object} { buffer, mimeType }
 */


function parseDataUri(uri) {
  var dataIndex = uri.indexOf(',');
  var buffer;
  var mimeType;

  if (uri.slice(dataIndex - 7, dataIndex) === ';base64') {
    buffer = new Buffer(uri.slice(dataIndex + 1), 'base64');
    mimeType = uri.slice(5, dataIndex - 7).trim();
  } else {
    buffer = new Buffer(decodeURIComponent(uri.slice(dataIndex + 1)));
    mimeType = uri.slice(5, dataIndex).trim();
  }

  if (!mimeType) {
    mimeType = 'text/plain;charset=US-ASCII';
  } else if (mimeType[0] === ';') {
    mimeType = "text/plain".concat(mimeType);
  }

  return {
    buffer: buffer,
    mimeType: mimeType
  };
}
//# sourceMappingURL=load-uri.js.map