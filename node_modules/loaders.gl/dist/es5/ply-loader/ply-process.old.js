"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePLY = parsePLY;
exports.generateNormals = generateNormals;
exports.normalizeXYZ = normalizeXYZ;

var _plyParser = _interopRequireDefault(require("./ply-parser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * parse ply data
 * @param {Binary} data
 * @return {*} parsed point cloud
 */
function parsePLY(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$normalize = options.normalize,
      normalize = _options$normalize === void 0 ? true : _options$normalize,
      _options$faceNormal = options.faceNormal,
      faceNormal = _options$faceNormal === void 0 ? true : _options$faceNormal,
      _options$vertexNormal = options.vertexNormal,
      vertexNormal = _options$vertexNormal === void 0 ? true : _options$vertexNormal,
      _options$flip = options.flip,
      flip = _options$flip === void 0 ? true : _options$flip; // Linearize the unnecessary callback interface from PLYloader

  var result = null;
  var parser = new _plyParser.default();

  parser.onsuccess = function (parsedData) {
    result = parsedData;
  };

  parser.onerror = function (error) {
    throw new Error(error);
  };

  parser.parse(data);

  if (result === null) {
    throw new Error('PLY parsing failed');
  }

  if (normalize) {
    normalizeXYZ(result.vertex);
  } // generate normals


  if (faceNormal && !result.face.normals || vertexNormal && !result.vertex.nx) {
    var _generateNormals = generateNormals(result, flip),
        face = _generateNormals.face,
        vertex = _generateNormals.vertex;

    if (faceNormal && !result.face.normals) {
      result.face.normals = face;
    }

    if (vertexNormal && !result.vertex.nx) {
      result.vertex.nx = vertex.nx;
      result.vertex.ny = vertex.ny;
      result.vertex.nz = vertex.nz;
    }
  }

  return {
    header: {},
    attributes: result
  };
}

function generateNormals(_ref, flip) {
  var _ref$vertex = _ref.vertex,
      x = _ref$vertex.x,
      y = _ref$vertex.y,
      z = _ref$vertex.z,
      triangles = _ref.face.vertex_indices;
  var normals = {
    face: [],
    vertex: {
      nx: Array(x.length).fill(0),
      ny: Array(y.length).fill(0),
      nz: Array(z.length).fill(0)
    }
  };
  triangles.forEach(function (vertices) {
    // get IDs of vertex in triangle
    var v0 = vertices[0];
    var v1 = vertices[1];
    var v2 = vertices[2]; // get edge vectors of each triganle

    var x0 = x[v2] - x[v0];
    var y0 = y[v2] - y[v0];
    var z0 = z[v2] - z[v0];
    var x1 = x[v1] - x[v0];
    var y1 = y[v1] - y[v0];
    var z1 = z[v1] - z[v0]; // get cross-product betwee the two edge vectors

    var nx = y0 * z1 - z0 * y1;
    var ny = z0 * x1 - x0 * z1;
    var nz = x0 * y1 - y0 * x1; // sum per-triangle normal to adjacent vertex

    vertices.forEach(function (v) {
      normals.vertex.nx[v] += nx;
      normals.vertex.ny[v] += ny;
      normals.vertex.nz[v] += nz;
    }); // normalize face normal

    var magnitude = Math.sqrt(nx * nx + ny * ny + nz * nz);
    nx = magnitude ? nx / magnitude : 0;
    ny = magnitude ? ny / magnitude : 0;
    nz = magnitude ? nz / magnitude : 0; // add per-triangle normal

    normals.face.push([nx, ny, nz]);
  }); // normalize vertex normals

  normals.vertex.nx.forEach(function (_, i) {
    var nx = normals.vertex.nx[i];
    var ny = normals.vertex.ny[i];
    var nz = normals.vertex.nz[i];
    var magnitude = Math.sqrt(nx * nx + ny * ny + nz * nz);
    magnitude *= flip ? -1 : 1;
    normals.vertex.nx[i] = magnitude ? normals.vertex.nx[i] / magnitude : 0;
    normals.vertex.ny[i] = magnitude ? normals.vertex.ny[i] / magnitude : 0;
    normals.vertex.nz[i] = magnitude ? normals.vertex.nz[i] / magnitude : 0;
  });
  return normals;
}
/**
 * normalize ply data position
 * @param {object} vertex with attributes x, y z
 * @return {*} normalized point cloud
 */


function normalizeXYZ(_ref2) {
  var x = _ref2.x,
      y = _ref2.y,
      z = _ref2.z;
  var n = x.length;
  var xMin = Infinity;
  var yMin = Infinity;
  var zMin = Infinity;
  var xMax = -Infinity;
  var yMax = -Infinity;
  var zMax = -Infinity;

  for (var i = 0; i < n; i++) {
    xMin = Math.min(xMin, x[i]);
    yMin = Math.min(yMin, y[i]);
    zMin = Math.min(zMin, z[i]);
    xMax = Math.max(xMax, x[i]);
    yMax = Math.max(yMax, y[i]);
    zMax = Math.max(zMax, z[i]);
  }

  var scale = Math.max.apply(Math, [xMax - xMin, yMax - yMin, zMax - zMin]);
  var xMid = (xMin + xMax) / 2;
  var yMid = (yMin + yMax) / 2;
  var zMid = (zMin + zMax) / 2;

  for (var _i = 0; _i < n; _i++) {
    x[_i] = (x[_i] - xMid) / scale;
    y[_i] = (y[_i] - yMid) / scale;
    z[_i] = (z[_i] - zMid) / scale;
  }
}
//# sourceMappingURL=ply-process.old.js.map