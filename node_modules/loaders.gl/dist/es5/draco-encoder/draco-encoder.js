"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Copyright 2017 The Draco Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/* eslint-disable no-console */

/* global console */
var draco3d = require('draco3d');

var assert = require('assert');

var DEFAULT_ENCODING_OPTIONS = {
  speed: [5, 5],
  method: 'MESH_EDGEBREAKER_ENCODING',
  quantization: {
    POSITION: 10
  }
};

var DRACOEncoder =
/*#__PURE__*/
function () {
  function DRACOEncoder() {
    _classCallCheck(this, DRACOEncoder);

    this.encoderModule = draco3d.createEncoderModule({});
    this.encoder = new this.encoderModule.Encoder();
  }

  _createClass(DRACOEncoder, [{
    key: "destroy",
    value: function destroy() {
      this.this.encoderModule.destroy(this.encoder);
      this.encoder = null;
      this.encoderModule = null;
    }
  }, {
    key: "destroyEncodedObject",
    value: function destroyEncodedObject(object) {
      if (object) {
        this.encoderModule.destroy(object);
      }
    } // Set encoding options.

  }, {
    key: "setOptions",
    value: function setOptions(opts) {
      if ('speed' in opts) {
        var _this$encoder;

        (_this$encoder = this.encoder).SetSpeedOptions.apply(_this$encoder, _toConsumableArray(opts.speed));
      }

      if ('method' in opts) {
        this.encoder.SetEncodingMethod(this.encoderModule[opts.method]);
      }

      if ('quantization' in opts) {
        for (var attribute in opts.quantization) {
          var bits = opts.quantization[attribute];
          this.encoder.SetAttributeQuantization(this.encoderModule[attribute], bits);
        }
      }
    }
  }, {
    key: "encodeCloud",
    value: function encodeCloud(mesh, decoder) {
      var newMesh = this.prepareMesh(mesh, decoder);
      this.setOptions(DEFAULT_ENCODING_OPTIONS); // Encoding.
      // console.log('Encoding...');

      var encodedData = new this.encoderModule.DracoInt8Array();
      var encodedLen = this.encoder.EncodeMeshToDracoBuffer(newMesh, encodedData);
      this.encoderModule.destroy(newMesh);

      if (!(encodedLen > 0)) {
        throw new Error('Draco encoding failed.');
      }

      console.log("Encoded size is ".concat(encodedLen)); // Copy encoded data to buffer.

      var outputBuffer = new ArrayBuffer(encodedLen);
      var outputData = new Int8Array(outputBuffer);

      for (var i = 0; i < encodedLen; ++i) {
        outputData[i] = encodedData.GetValue(i);
      }

      this.encoderModule.destroy(encodedData);
      return outputData;
    }
  }, {
    key: "encodeMesh",
    value: function encodeMesh(mesh, decoder) {
      var newMesh = this.prepareMesh(mesh, decoder);
      this.setOptions(DEFAULT_ENCODING_OPTIONS); // Encoding.
      // console.log('Encoding...');

      var encodedData = new this.encoderModule.DracoInt8Array();
      var encodedLen = this.encoder.EncodeMeshToDracoBuffer(newMesh, encodedData);
      this.encoderModule.destroy(newMesh);

      if (!(encodedLen > 0)) {
        throw new Error('Draco encoding failed.');
      }

      console.log("Encoded size is ".concat(encodedLen)); // Copy encoded data to buffer.

      var outputBuffer = new ArrayBuffer(encodedLen);
      var outputData = new Int8Array(outputBuffer);

      for (var i = 0; i < encodedLen; ++i) {
        outputData[i] = encodedData.GetValue(i);
      }

      this.encoderModule.destroy(encodedData); // this.encoderModule.destroy(meshBuilder);

      return outputData;
    }
  }, {
    key: "prepareMesh",
    value: function prepareMesh(mesh, decoder) {
      var numFaces = mesh.num_faces();
      var numIndices = numFaces * 3;
      var numPoints = mesh.num_points();
      var indices = new Uint32Array(numIndices);
      console.log("Number of faces ".concat(numFaces));
      console.log("Number of vertices ".concat(numPoints));
      var meshBuilder = new this.encoderModule.MeshBuilder(); // Add Faces to mesh

      var integerArray = new this.decoderModule.DracoInt32Array();

      for (var i = 0; i < numFaces; ++i) {
        decoder.GetFaceFromMesh(mesh, i, integerArray);
        var index = i * 3;
        indices[index] = integerArray.GetValue(0);
        indices[index + 1] = integerArray.GetValue(1);
        indices[index + 2] = integerArray.GetValue(2);
      }

      this.decoderModule.destroy(integerArray); // Create a mesh object for storing mesh data.

      var newMesh = new this.encoderModule.Mesh();
      meshBuilder.AddFacesToMesh(newMesh, numFaces, indices);

      this._prepareMeshAttributes(mesh, newMesh, numPoints, meshBuilder, decoder);

      this.encoderModule.destroy(meshBuilder);
      return newMesh;
    }
  }, {
    key: "_prepareMeshAttributes",
    value: function _prepareMeshAttributes(mesh, newMesh, numPoints, meshBuilder, decoder) {
      var _this = this;

      var attrs = {
        POSITION: 3,
        NORMAL: 3,
        COLOR: 3,
        TEX_COORD: 2
      };
      Object.keys(attrs).forEach(function (attr) {
        var stride = attrs[attr];
        var numValues = numPoints * stride;
        var decoderAttr = _this.decoderModule[attr];
        var encoderAttr = _this.encoderModule[attr];
        var attrId = decoder.GetAttributeId(mesh, decoderAttr);

        if (attrId < 0) {
          return;
        }

        console.log("Adding ".concat(attr, " attribute"));
        var attribute = decoder.GetAttribute(mesh, attrId);
        var attributeData = new _this.decoderModule.DracoFloat32Array();
        decoder.GetAttributeFloatForAllPoints(mesh, attribute, attributeData);
        assert(numValues === attributeData.size(), 'Wrong attribute size.');
        var attributeDataArray = new Float32Array(numValues);

        for (var i = 0; i < numValues; ++i) {
          attributeDataArray[i] = attributeData.GetValue(i);
        }

        _this.decoderModule.destroy(attributeData);

        meshBuilder.AddFloatAttributeToMesh(newMesh, encoderAttr, numPoints, stride, attributeDataArray);
      });
    }
  }]);

  return DRACOEncoder;
}();
/*
  encodeMesh(mesh, decoder) {
    const encoder = new this.encoderModule.Encoder();
    const meshBuilder = new this.encoderModule.MeshBuilder();

    // Create a mesh object for storing mesh data.
    const newMesh = new this.encoderModule.Mesh();

    const numFaces = mesh.num_faces();
    const numIndices = numFaces * 3;
    const numPoints = mesh.num_points();
    const indices = new Uint32Array(numIndices);

    console.log("Number of faces " + numFaces);
    console.log("Number of vertices " + numPoints);

    // Add Faces to mesh
    const ia = new this.decoderModule.DracoInt32Array();
    for (let i = 0; i < numFaces; ++i) {
      decoder.GetFaceFromMesh(mesh, i, ia);
      const index = i * 3;
      indices[index] = ia.GetValue(0);
      indices[index + 1] = ia.GetValue(1);
      indices[index + 2] = ia.GetValue(2);
    }
    this.decoderModule.destroy(ia);
    meshBuilder.AddFacesToMesh(newMesh, numFaces, indices);

    const attrs = {POSITION: 3, NORMAL: 3, COLOR: 3, TEX_COORD: 2};

    Object.keys(attrs).forEach((attr) => {
      const stride = attrs[attr];
      const numValues = numPoints * stride;
      const decoderAttr = this.decoderModule[attr];
      const encoderAttr = this.encoderModule[attr];
      const attrId = decoder.GetAttributeId(mesh, decoderAttr);

      if (attrId < 0) {
        return;
      }

      console.log("Adding %s attribute", attr);

      const attribute = decoder.GetAttribute(mesh, attrId);
      const attributeData = new this.decoderModule.DracoFloat32Array();
      decoder.GetAttributeFloatForAllPoints(mesh, attribute, attributeData);

      assert(numValues === attributeData.size(), 'Wrong attribute size.');

      const attributeDataArray = new Float32Array(numValues);
      for (let i = 0; i < numValues; ++i) {
        attributeDataArray[i] = attributeData.GetValue(i);
      }

      this.decoderModule.destroy(attributeData);
      meshBuilder.AddFloatAttributeToMesh(newMesh, encoderAttr, numPoints,
          stride, attributeDataArray);
    });

    let encodedData = new this.encoderModule.DracoInt8Array();
    // Set encoding options.
    encoder.SetSpeedOptions(5, 5);
    encoder.SetAttributeQuantization(this.encoderModule.POSITION, 10);
    encoder.SetEncodingMethod(this.encoderModule.MESH_EDGEBREAKER_ENCODING);

    // Encoding.
    console.log("Encoding...");
    const encodedLen = encoder.EncodeMeshToDracoBuffer(newMesh,
                                                       encodedData);
    this.encoderModule.destroy(newMesh);

    if (encodedLen > 0) {
      console.log("Encoded size is " + encodedLen);
    } else {
      console.log("Error: Encoding failed.");
    }
    // Copy encoded data to buffer.
    const outputBuffer = new ArrayBuffer(encodedLen);
    const outputData = new Int8Array(outputBuffer);
    for (let i = 0; i < encodedLen; ++i) {
      outputData[i] = encodedData.GetValue(i);
    }

    this.encoderModule.destroy(encodedData);
    this.encoderModule.destroy(encoder);
    this.encoderModule.destroy(meshBuilder);

    return outputData;
  }
*/


exports.default = DRACOEncoder;
//# sourceMappingURL=draco-encoder.js.map