"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseLAZ = parseLAZ;

var _laslaz = require("./laslaz");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * parse laz data
 * @param {Binary} data
 * @return {*} parsed point cloud
 */
function parseLAZ(rawData, skip, onParseData) {
  var dataHandler = new _laslaz.LASFile(rawData);
  return dataHandler.open() // open data
  .then(function () {
    dataHandler.isOpen = true;
    return dataHandler;
  }) // attch header
  .then(function (data) {
    return data.getHeader().then(function (header) {
      return [data, header];
    });
  }) // start loading
  .then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        data = _ref2[0],
        header = _ref2[1];

    var Unpacker = data.getUnpacker();
    var totalToRead = header.pointsCount / Math.max(1, skip);
    var totalRead = 0;

    var reader = function reader() {
      return data.readData(1000 * 100, 0, skip).then(function (chunk) {
        totalRead += chunk.count;
        var unpacker = new Unpacker(chunk.buffer, chunk.count, header); // surface unpacker and progress via call back
        // use unpacker.pointsCount and unpacker.getPoint(i) to handle data in app

        onParseData(unpacker, totalRead / totalToRead);

        if (chunk.hasMoreData && totalRead < totalToRead) {
          return reader();
        }

        header.totalRead = totalRead;
        header.versionAsString = chunk.versionAsString;
        header.isCompressed = chunk.isCompressed;
        return [chunk, header];
      });
    };

    return reader();
  }) // done loading, close file
  .then(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        data = _ref4[0],
        header = _ref4[1];

    dataHandler.close().then(function () {
      dataHandler.isOpen = false; // trim the LASFile which we don't really want to pass to the user

      return header;
    });
  }) // handle exceptions
  .catch(function (e) {
    // make sure the data is closed, if the data is open close and then fail
    if (dataHandler.isOpen) {
      return dataHandler.close().then(function () {
        dataHandler.isOpen = false;
        throw e;
      });
    }

    throw e;
  });
}
//# sourceMappingURL=parse-laz.js.map