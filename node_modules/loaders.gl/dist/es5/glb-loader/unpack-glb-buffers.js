"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = unpackGLBBuffers;

var _assert = _interopRequireDefault(require("../common/loader-utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TYPE_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var COMPONENT_TYPE_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var COMPONENT_TYPE_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};

function unpackGLBBuffers(arrayBuffer, json, binaryByteOffset) {
  // TODO - really inefficient, should just use the offset into the original array buffer
  if (binaryByteOffset) {
    arrayBuffer = getArrayBufferAtOffset(arrayBuffer, binaryByteOffset);
  }

  var bufferViews = json.bufferViews || [];

  for (var i = 0; i < bufferViews.length; ++i) {
    var bufferView = bufferViews[i];
    (0, _assert.default)(bufferView.byteLength >= 0);
  }

  return {
    accessors: unpackAccessors(arrayBuffer, bufferViews, json),
    images: unpackImages(arrayBuffer, bufferViews, json)
  };
}

function unpackAccessors(arrayBuffer, bufferViews, json) {
  // unpack accessors
  var accessors = json.accessors || [];
  var accessorBuffers = [];

  for (var i = 0; i < accessors.length; ++i) {
    var accessor = accessors[i];
    (0, _assert.default)(accessor);
    var bufferView = bufferViews[accessor.bufferView];
    (0, _assert.default)(bufferView); // Create a new typed array as a view into the combined buffer

    var _getArrayTypeAndLengt = getArrayTypeAndLength(accessor, bufferView),
        ArrayType = _getArrayTypeAndLengt.ArrayType,
        length = _getArrayTypeAndLengt.length;

    var array = new ArrayType(arrayBuffer, bufferView.byteOffset, length); // Store the metadata on the array (e.g. needed to determine number of components per element)

    array.accessor = accessor;
    accessorBuffers.push(array);
  }

  return accessorBuffers;
}

function unpackImages(arrayBuffer, bufferViews, json) {
  // unpack images
  var images = json.images || [];
  var imageBuffers = [];

  for (var i = 0; i < images.length; ++i) {
    var image = images[i];
    (0, _assert.default)(image);
    var bufferView = bufferViews[image.bufferView];
    (0, _assert.default)(bufferView); // Create a new typed array as a view into the combined buffer

    var array = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength); // Store the metadata on the array (e.g. needed to determine number of components per element)

    array.imate = image;
    imageBuffers.push(array);
  }

  return imageBuffers;
} // Helper methods


function getArrayTypeAndLength(accessor, bufferView) {
  var ArrayType = COMPONENT_TYPE_ARRAY[accessor.componentType];
  var components = TYPE_COMPONENTS[accessor.type];
  var bytesPerComponent = COMPONENT_TYPE_BYTE_SIZE[accessor.componentType];
  var length = accessor.count * components;
  var byteLength = accessor.count * components * bytesPerComponent;
  (0, _assert.default)(byteLength >= 0 && byteLength <= bufferView.byteLength);
  return {
    ArrayType: ArrayType,
    length: length,
    byteLength: byteLength
  };
} // json.accessors = json.accessors || [];
// json.bufferViews = json.bufferViews || [];
// Creates a new ArrayBuffer starting at the offset, containing all remaining bytes
// TODO - should not be needed, see above


function getArrayBufferAtOffset(arrayBuffer, byteOffset) {
  var length = arrayBuffer.byteLength - byteOffset;
  var binaryBuffer = new ArrayBuffer(length);
  var sourceArray = new Uint8Array(arrayBuffer);
  var binaryArray = new Uint8Array(binaryBuffer);

  for (var i = 0; i < length; i++) {
    binaryArray[i] = sourceArray[byteOffset + i];
  }

  return binaryBuffer;
}
//# sourceMappingURL=unpack-glb-buffers.js.map