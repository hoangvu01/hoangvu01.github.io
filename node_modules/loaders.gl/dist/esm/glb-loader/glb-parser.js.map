{"version":3,"sources":["../../../src/glb-loader/glb-parser.js"],"names":["unpackGLBBuffers","unpackBinaryJson","padTo4Bytes","TextDecoder","assert","MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","LE","BE","getMagicString","dataView","String","fromCharCode","getUint8","GLBParser","glbArrayBuffer","options","_parseBinary","json","binaryByteOffset","unpackedBuffers","unpackedJson","_getApplicationJSON","jsonKey","glTF","Object","assign","magic","DataView","magic1","getUint32","version","fileLength","valid","console","warn","jsonChunkLength","jsonChunkFormat","jsonChunkOffset","jsonChunk","Uint8Array","textDecoder","jsonText","decode","JSON","parse","binaryChunkStart","binChunkFormat","arrayBuffer"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements */\nimport unpackGLBBuffers from './unpack-glb-buffers';\nimport unpackBinaryJson from './unpack-binary-json';\nimport {padTo4Bytes} from '../common/loader-utils/array-utils';\nimport TextDecoder from '../common/loader-utils/text-decoder';\nimport assert from '../common/loader-utils/assert';\n\n// glTF CONSTANTS\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\nconst LE = true; // Binary GLTF is little endian.\nconst BE = false; // Magic needs to be written as BE\n\n// glTF ACCESSOR CONSTANTS\n\n/*\nconst TYPE_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst COMPONENT_TYPE_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst COMPONENT_TYPE_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n*/\n\nfunction getMagicString(dataView) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(0))}\\\n${String.fromCharCode(dataView.getUint8(1))}\\\n${String.fromCharCode(dataView.getUint8(2))}\\\n${String.fromCharCode(dataView.getUint8(3))}`;\n}\n\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\nexport default class GLBParser {\n  constructor(glbArrayBuffer) {\n    this.glbArrayBuffer = glbArrayBuffer;\n  }\n\n  // Only returns application JSON\n  parse(options = {}) {\n    const {json, binaryByteOffset} = this._parseBinary(this.glbArrayBuffer, options);\n    const unpackedBuffers = unpackGLBBuffers(this.glbArrayBuffer, json, binaryByteOffset);\n    const unpackedJson = unpackBinaryJson(json, unpackedBuffers);\n    return this._getApplicationJSON(unpackedJson, options);\n  }\n\n  // Returns both application JSON and glTF JSON, separated\n  parseWithMetadata(options = {}) {\n    const {json, binaryByteOffset} = this._parseBinary(this.glbArrayBuffer, options);\n    const unpackedBuffers = unpackGLBBuffers(this.glbArrayBuffer, json, binaryByteOffset);\n    const unpackedJson = unpackBinaryJson(json, unpackedBuffers);\n    return unpackedJson;\n  }\n\n  // PRIVATE\n\n  // Get JSON from json key\n  _getApplicationJSON(json, options) {\n    const jsonKey = options.jsonKey || 'json';\n    // Create glTF metadata object, with deleted application json key\n    const glTF = Object.assign({}, json);\n    delete glTF[jsonKey];\n    return {json: json[jsonKey], glTF};\n  }\n\n  _parseBinary(options = {}) {\n    const {magic = MAGIC_glTF} = options;\n\n    // GLB Header\n    const dataView = new DataView(this.glbArrayBuffer);\n    const magic1 = dataView.getUint32(0, BE); // Magic number (the ASCII string 'glTF').\n    const version = dataView.getUint32(4, LE); // Version 2 of binary glTF container format\n    const fileLength = dataView.getUint32(8, LE); // Total byte length of generated file\n\n    let valid = magic1 === MAGIC_glTF || magic1 === magic;\n    if (!valid) {\n      console.warn(`Invalid GLB magic string ${getMagicString(dataView)}`); // eslint-disable-line\n    }\n\n    assert(version === 2, `Invalid GLB version ${version}. Only .glb v2 supported`);\n    assert(fileLength > 20);\n\n    // Write the JSON chunk\n    const jsonChunkLength = dataView.getUint32(12, LE); // Byte length of json chunk\n    const jsonChunkFormat = dataView.getUint32(16, LE); // Chunk format as uint32\n\n    valid = jsonChunkFormat === GLB_CHUNK_TYPE_JSON || jsonChunkFormat === 0; // Back compat\n    assert(valid, `JSON chunk format ${jsonChunkFormat}`);\n\n    // Create a \"view\" of the binary encoded JSON data\n    const jsonChunkOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE; // First headers: 20 bytes\n    const jsonChunk = new Uint8Array(this.glbArrayBuffer, jsonChunkOffset, jsonChunkLength);\n\n    // Decode the JSON binary array into clear text\n    const textDecoder = new TextDecoder('utf8');\n    const jsonText = textDecoder.decode(jsonChunk);\n\n    // Parse the JSON text into a JavaScript data structure\n    const json = JSON.parse(jsonText);\n\n    // TODO - BIN chunk can be optional\n    const binaryChunkStart = jsonChunkOffset + padTo4Bytes(jsonChunkLength);\n    const binaryByteOffset = binaryChunkStart + GLB_CHUNK_HEADER_SIZE;\n\n    const binChunkFormat = dataView.getUint32(binaryChunkStart + 4, LE); // Chunk format as uint32\n    valid = binChunkFormat === GLB_CHUNK_TYPE_BIN || binChunkFormat === 1; // Back compat\n    assert(valid, `BIN chunk format ${binChunkFormat}`);\n\n    return {arrayBuffer: this.glbArrayBuffer, binaryByteOffset, json};\n  }\n\n  /*\n  unpackBinaryObjects() {\n    const unpackedBinaryObjects = {\n      images: [],\n      accessors: []\n    };\n\n    const images = this.json.images || [];\n    for (const glTFImage of images) {\n      unpackedBinaryObjects.images.push(this.unpackImage(glTFImage));\n    }\n\n    const accessors = this.json.accessors || [];\n    for (const glTFAccessor of accessors) {\n      unpackedBinaryObjects.accessors.push(this.unpackAccessor(glTFAccessor));\n    }\n\n    return unpackedBinaryObjects;\n  }\n\n  unpackImage(glTFImage) {\n    /* global window, Blob, Image *\n    const arrayBufferView = this.unpackBufferView(glTFImage.bufferView);\n    const mimeType = glTFImage.mimeType || 'image/jpeg';\n    const blob = new Blob([arrayBufferView], {type: mimeType});\n    const urlCreator = window.URL || window.webkitURL;\n    const imageUrl = urlCreator.createObjectURL(blob);\n    const img = new Image();\n    img.src = imageUrl;\n    return img;\n  }\n\n  unpackAccessor(glTFAccessor) {\n    // Decode the glTF accessor format\n    const ArrayType = COMPONENT_TYPE_ARRAY[glTFAccessor.componentType];\n    const components = TYPE_COMPONENTS[glTFAccessor.type];\n    const bytesPerComponent = COMPONENT_TYPE_BYTE_SIZE[glTFAccessor.componentType];\n    const length = glTFAccessor.count * components;\n    const byteLength = glTFAccessor.count * components * bytesPerComponent;\n\n    // Get the boundaries of the binary sub-chunk for this bufferView\n    const glTFBufferView = this.json.bufferViews[glTFAccessor.bufferView];\n    assert(byteLength >= 0 && byteLength <= glTFBufferView.byteLength);\n\n    const byteOffset = glTFBufferView.byteOffset + this.binaryByteOffset;\n    return new ArrayType(this.arrayBuffer, byteOffset, length);\n  }\n\n  // Create a new typed array as a view into the binary chunk\n  unpackBufferView(glTFBufferView) {\n    const byteOffset = glTFBufferView.byteOffset + this.binaryByteOffset;\n    return new Uint8Array(byteOffset, glTFBufferView.byteLength);\n  }\n  */\n}\n"],"file":"glb-parser.js"}