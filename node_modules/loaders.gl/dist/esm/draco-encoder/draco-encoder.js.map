{"version":3,"sources":["../../../src/draco-encoder/draco-encoder.js"],"names":["draco3d","require","assert","DEFAULT_ENCODING_OPTIONS","speed","method","quantization","POSITION","DRACOEncoder","encoderModule","createEncoderModule","encoder","Encoder","this","destroy","object","opts","SetSpeedOptions","SetEncodingMethod","attribute","bits","SetAttributeQuantization","mesh","decoder","newMesh","prepareMesh","setOptions","encodedData","DracoInt8Array","encodedLen","EncodeMeshToDracoBuffer","Error","console","log","outputBuffer","ArrayBuffer","outputData","Int8Array","i","GetValue","numFaces","num_faces","numIndices","numPoints","num_points","indices","Uint32Array","meshBuilder","MeshBuilder","integerArray","decoderModule","DracoInt32Array","GetFaceFromMesh","index","Mesh","AddFacesToMesh","_prepareMeshAttributes","attrs","NORMAL","COLOR","TEX_COORD","Object","keys","forEach","attr","stride","numValues","decoderAttr","encoderAttr","attrId","GetAttributeId","GetAttribute","attributeData","DracoFloat32Array","GetAttributeFloatForAllPoints","size","attributeDataArray","Float32Array","AddFloatAttributeToMesh"],"mappings":"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","sourcesContent":["// Copyright 2017 The Draco Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the 'License');\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an 'AS IS' BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n/* eslint-disable no-console */\n/* global console */\nconst draco3d = require('draco3d');\nconst assert = require('assert');\n\nconst DEFAULT_ENCODING_OPTIONS = {\n  speed: [5, 5],\n  method: 'MESH_EDGEBREAKER_ENCODING',\n  quantization: {\n    POSITION: 10\n  }\n};\n\nexport default class DRACOEncoder {\n  constructor() {\n    this.encoderModule = draco3d.createEncoderModule({});\n    this.encoder = new this.encoderModule.Encoder();\n  }\n\n  destroy() {\n    this.this.encoderModule.destroy(this.encoder);\n    this.encoder = null;\n    this.encoderModule = null;\n  }\n\n  destroyEncodedObject(object) {\n    if (object) {\n      this.encoderModule.destroy(object);\n    }\n  }\n\n  // Set encoding options.\n  setOptions(opts) {\n    if ('speed' in opts) {\n      this.encoder.SetSpeedOptions(...opts.speed);\n    }\n    if ('method' in opts) {\n      this.encoder.SetEncodingMethod(this.encoderModule[opts.method]);\n    }\n    if ('quantization' in opts) {\n      for (const attribute in opts.quantization) {\n        const bits = opts.quantization[attribute];\n        this.encoder.SetAttributeQuantization(this.encoderModule[attribute], bits);\n      }\n    }\n  }\n\n  encodeCloud(mesh, decoder) {\n\n    const newMesh = this.prepareMesh(mesh, decoder);\n\n    this.setOptions(DEFAULT_ENCODING_OPTIONS);\n\n    // Encoding.\n    // console.log('Encoding...');\n    const encodedData = new this.encoderModule.DracoInt8Array();\n    const encodedLen = this.encoder.EncodeMeshToDracoBuffer(newMesh, encodedData);\n    this.encoderModule.destroy(newMesh);\n    if (!(encodedLen > 0)) {\n      throw new Error('Draco encoding failed.');\n    }\n\n    console.log(`Encoded size is ${encodedLen}`);\n\n    // Copy encoded data to buffer.\n    const outputBuffer = new ArrayBuffer(encodedLen);\n    const outputData = new Int8Array(outputBuffer);\n    for (let i = 0; i < encodedLen; ++i) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n\n    this.encoderModule.destroy(encodedData);\n\n    return outputData;\n  }\n\n  encodeMesh(mesh, decoder) {\n\n    const newMesh = this.prepareMesh(mesh, decoder);\n\n    this.setOptions(DEFAULT_ENCODING_OPTIONS);\n\n    // Encoding.\n    // console.log('Encoding...');\n    const encodedData = new this.encoderModule.DracoInt8Array();\n    const encodedLen = this.encoder.EncodeMeshToDracoBuffer(newMesh, encodedData);\n    this.encoderModule.destroy(newMesh);\n    if (!(encodedLen > 0)) {\n      throw new Error('Draco encoding failed.');\n    }\n\n    console.log(`Encoded size is ${encodedLen}`);\n\n    // Copy encoded data to buffer.\n    const outputBuffer = new ArrayBuffer(encodedLen);\n    const outputData = new Int8Array(outputBuffer);\n    for (let i = 0; i < encodedLen; ++i) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n\n    this.encoderModule.destroy(encodedData);\n    // this.encoderModule.destroy(meshBuilder);\n\n    return outputData;\n  }\n\n  prepareMesh(mesh, decoder) {\n    const numFaces = mesh.num_faces();\n    const numIndices = numFaces * 3;\n    const numPoints = mesh.num_points();\n    const indices = new Uint32Array(numIndices);\n\n    console.log(`Number of faces ${numFaces}`);\n    console.log(`Number of vertices ${numPoints}`);\n\n    const meshBuilder = new this.encoderModule.MeshBuilder();\n\n    // Add Faces to mesh\n    const integerArray = new this.decoderModule.DracoInt32Array();\n    for (let i = 0; i < numFaces; ++i) {\n      decoder.GetFaceFromMesh(mesh, i, integerArray);\n      const index = i * 3;\n      indices[index] = integerArray.GetValue(0);\n      indices[index + 1] = integerArray.GetValue(1);\n      indices[index + 2] = integerArray.GetValue(2);\n    }\n    this.decoderModule.destroy(integerArray);\n\n    // Create a mesh object for storing mesh data.\n    const newMesh = new this.encoderModule.Mesh();\n    meshBuilder.AddFacesToMesh(newMesh, numFaces, indices);\n\n    this._prepareMeshAttributes(mesh, newMesh, numPoints, meshBuilder, decoder);\n\n    this.encoderModule.destroy(meshBuilder);\n\n    return newMesh;\n  }\n\n  _prepareMeshAttributes(mesh, newMesh, numPoints, meshBuilder, decoder) {\n    const attrs = {POSITION: 3, NORMAL: 3, COLOR: 3, TEX_COORD: 2};\n\n    Object.keys(attrs).forEach((attr) => {\n      const stride = attrs[attr];\n      const numValues = numPoints * stride;\n      const decoderAttr = this.decoderModule[attr];\n      const encoderAttr = this.encoderModule[attr];\n      const attrId = decoder.GetAttributeId(mesh, decoderAttr);\n\n      if (attrId < 0) {\n        return;\n      }\n\n      console.log(`Adding ${attr} attribute`);\n\n      const attribute = decoder.GetAttribute(mesh, attrId);\n      const attributeData = new this.decoderModule.DracoFloat32Array();\n      decoder.GetAttributeFloatForAllPoints(mesh, attribute, attributeData);\n\n      assert(numValues === attributeData.size(), 'Wrong attribute size.');\n\n      const attributeDataArray = new Float32Array(numValues);\n      for (let i = 0; i < numValues; ++i) {\n        attributeDataArray[i] = attributeData.GetValue(i);\n      }\n\n      this.decoderModule.destroy(attributeData);\n      meshBuilder.AddFloatAttributeToMesh(newMesh, encoderAttr, numPoints,\n          stride, attributeDataArray);\n    });\n  }\n}\n\n/*\n  encodeMesh(mesh, decoder) {\n    const encoder = new this.encoderModule.Encoder();\n    const meshBuilder = new this.encoderModule.MeshBuilder();\n\n    // Create a mesh object for storing mesh data.\n    const newMesh = new this.encoderModule.Mesh();\n\n    const numFaces = mesh.num_faces();\n    const numIndices = numFaces * 3;\n    const numPoints = mesh.num_points();\n    const indices = new Uint32Array(numIndices);\n\n    console.log(\"Number of faces \" + numFaces);\n    console.log(\"Number of vertices \" + numPoints);\n\n    // Add Faces to mesh\n    const ia = new this.decoderModule.DracoInt32Array();\n    for (let i = 0; i < numFaces; ++i) {\n      decoder.GetFaceFromMesh(mesh, i, ia);\n      const index = i * 3;\n      indices[index] = ia.GetValue(0);\n      indices[index + 1] = ia.GetValue(1);\n      indices[index + 2] = ia.GetValue(2);\n    }\n    this.decoderModule.destroy(ia);\n    meshBuilder.AddFacesToMesh(newMesh, numFaces, indices);\n\n    const attrs = {POSITION: 3, NORMAL: 3, COLOR: 3, TEX_COORD: 2};\n\n    Object.keys(attrs).forEach((attr) => {\n      const stride = attrs[attr];\n      const numValues = numPoints * stride;\n      const decoderAttr = this.decoderModule[attr];\n      const encoderAttr = this.encoderModule[attr];\n      const attrId = decoder.GetAttributeId(mesh, decoderAttr);\n\n      if (attrId < 0) {\n        return;\n      }\n\n      console.log(\"Adding %s attribute\", attr);\n\n      const attribute = decoder.GetAttribute(mesh, attrId);\n      const attributeData = new this.decoderModule.DracoFloat32Array();\n      decoder.GetAttributeFloatForAllPoints(mesh, attribute, attributeData);\n\n      assert(numValues === attributeData.size(), 'Wrong attribute size.');\n\n      const attributeDataArray = new Float32Array(numValues);\n      for (let i = 0; i < numValues; ++i) {\n        attributeDataArray[i] = attributeData.GetValue(i);\n      }\n\n      this.decoderModule.destroy(attributeData);\n      meshBuilder.AddFloatAttributeToMesh(newMesh, encoderAttr, numPoints,\n          stride, attributeDataArray);\n    });\n\n    let encodedData = new this.encoderModule.DracoInt8Array();\n    // Set encoding options.\n    encoder.SetSpeedOptions(5, 5);\n    encoder.SetAttributeQuantization(this.encoderModule.POSITION, 10);\n    encoder.SetEncodingMethod(this.encoderModule.MESH_EDGEBREAKER_ENCODING);\n\n    // Encoding.\n    console.log(\"Encoding...\");\n    const encodedLen = encoder.EncodeMeshToDracoBuffer(newMesh,\n                                                       encodedData);\n    this.encoderModule.destroy(newMesh);\n\n    if (encodedLen > 0) {\n      console.log(\"Encoded size is \" + encodedLen);\n    } else {\n      console.log(\"Error: Encoding failed.\");\n    }\n    // Copy encoded data to buffer.\n    const outputBuffer = new ArrayBuffer(encodedLen);\n    const outputData = new Int8Array(outputBuffer);\n    for (let i = 0; i < encodedLen; ++i) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n\n    this.encoderModule.destroy(encodedData);\n    this.encoderModule.destroy(encoder);\n    this.encoderModule.destroy(meshBuilder);\n\n    return outputData;\n  }\n*/\n"],"file":"draco-encoder.js"}